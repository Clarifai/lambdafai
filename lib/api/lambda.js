var async = require('async');
var paths = require('../internal/paths');
var strings = require('../internal/strings');


var Lambda = function(app, opts) {
  strings.checkIdentifier(opts.name, 'lambda name');
  this.name = opts.name;
  this.description = opts.description || (opts.name + ' (generated by Lambdafai)');
  this.ram = opts.ram || 128;
  this.timeout = opts.timeout || 10;
  this.routes = [];
  this.handlers = [];
};

Lambda.prototype.get = function(path, handler) {
  this._addHandler({method: 'GET', path: path, handler: handler });
};

Lambda.prototype.post = function(path, handler) {
  this._addHandler({method: 'POST', path: path, handler: handler });
};

Lambda.prototype.put = function(path, handler) {
  this._addHandler({method: 'PUT', path: path, handler: handler });
};

Lambda.prototype.head = function(path, handler) {
  this._addHandler({method: 'HEAD', path: path, handler: handler });
};

Lambda.prototype.delete = function(path, handler) {
  this._addHandler({method: 'DELETE', path: path, handler: handler });
};

Lambda.prototype.options = function(path, handler) {
  this._addHandler({method: 'OPTIONS', path: path, handler: handler });
};

Lambda.prototype.use = function(middleware) {
  this._addHandler({ handler: middleware });
};

Lambda.prototype._addHandler = function(handler) {
  this.handlers.push(handler);
  if (handler.method && handler.path) {
    checkConflictingRoutes(this.routes, handler);
    this.routes.push(handler);
  }
};

Lambda.prototype._handleRequest = function(req, res) {
  var handlers = this.handlers.filter(function(handler) {
    return canHandleRequest(handler, req);
  });
  var callback = res._callback;
  async.eachSeries(handlers, function(handler, next) {
    res._callback = next;
    handler.handler(req, res);
  }, callback);
};

function canHandleRequest(handler, req) {
  return (!handler.method || handler.method == req.method) &&
      (!handler.path || paths.matchPath(handler.path, req.path));
}

function checkConflictingRoutes(routes, route) {
  for (var i = 0; i < routes.length; i++) {
    var r = routes[i];
    if (r.method == route.method &&
        (paths.matchPath(r.path, route.path) || paths.matchPath(route.path, r.path))) {
      throw new Error('Conflicting routes: ' + JSON.stringify(r) + ' and ' + JSON.stringify(route));
    }
  }
}

module.exports = Lambda;
