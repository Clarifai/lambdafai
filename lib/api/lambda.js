var async = require('async');
var _ = require('lodash');
var paths = require('../internal/paths');
var strings = require('../internal/strings');

/**
 * The Lambda object represents a Lambda function in the application. It is returned by
 * {@link Application#lambda} when a new function is registered. You should not call this
 * constructor directly.
 *
 * The Lambda object has methods for:
 *   * Routing HTTP and S3 requests; see {@link Lambda#get}, {@link Lambda#s3put}, etc.
 *   * Adding middleware; see {@link Lambda#use}
 *
 * @constructor
 */
var Lambda = function(app, opts) {
  strings.checkIdentifier(opts.name, 'lambda name');
  this.name = opts.name;
  this.description = opts.description || (opts.name + ' (generated by Lambdafai)');
  this.ram = opts.ram || 128;
  this.timeout = opts.timeout || 10;
  this.handlers = [];
};

/**
 * Routes HTTP GET requests for a given path to the handler. Paths can include placeholders
 * prefixed with a colon, e.g. `/items/:id`, which will match paths like `/items/123`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.get = function(path, handler) {
  this._addHandler({type: 'route', method: 'GET', path: path, handler: handler });
  return this;
};

/**
 * Routes HTTP POST requests for a given path to the handler. Paths can include placeholders
 * prefixed with a colon, e.g. `/items/:id`, which will match paths like `/items/123`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.post = function(path, handler) {
  this._addHandler({type: 'route', method: 'POST', path: path, handler: handler });
  return this;
};

/**
 * Routes HTTP PUT requests for a given path to the handler. Paths can include placeholders
 * prefixed with a colon, e.g. `/items/:id`, which will match paths like `/items/123`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.put = function(path, handler) {
  this._addHandler({type: 'route', method: 'PUT', path: path, handler: handler });
  return this;
};

/**
 * Routes HTTP DELETE requests for a given path to the handler. Paths can include placeholders
 * prefixed with a colon, e.g. `/items/:id`, which will match paths like `/items/123`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.delete = function(path, handler) {
  this._addHandler({type: 'route', method: 'DELETE', path: path, handler: handler });
  return this;
};

/**
 * Routes HTTP OPTIONS requests for a given path to the handler. Paths can include placeholders
 * prefixed with a colon, e.g. `/items/:id`, which will match paths like `/items/123`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.options = function(path, handler) {
  this._addHandler({type: 'route', method: 'OPTIONS', path: path, handler: handler });
  return this;
};

/**
 * Routes S3 PUT requests for a given path to the handler. S3 paths will be the key in the bucket,
 * and can include placeholders prefixed with a colon, e.g. `/items/:id`
 * @param path {string} the path to register the handler at
 * @param handler {function} function with signature `function(req, res)` for handling the request
 */
Lambda.prototype.s3put = function(path, handler) {
  this._addHandler({type: 'route', method: 'S3PUT', path: path, handler: handler });
  return this;
};

/**
 * Mounts specified Lambda-level middleware function. Middleware are functions that intercept
 * the request before or after the handler. Middleware must call `res.next()` to pass control to
 * the next middleware in the chain.
 *
 * @param {function} middleware - the middleware function
 */
Lambda.prototype.use = function(middleware) {
  this._addHandler({type: 'middleware', handler: middleware});
  return this;
};

Lambda.prototype._addHandler = function(handler) {
  if (handler.type == 'route') {
    checkConflictingRoutes(this.handlers, handler);
  }
  this.handlers.push(handler);
};

Lambda.prototype._handleRequest = function(req, res) {
  var callback = res._callback;
  var matchingRoutes = _.filter(this.handlers, function(h) {
    return h.type == 'route' && (h.method == req.method && paths.match(h.path, req.path));
  });
  if (matchingRoutes.length === 0 || req.isDone) {
    callback(null);  // No routes matched the request. Move along.
    return;
  }

  var matchingHandlers = _.filter(this.handlers, function(h) {
    return h.type == 'middleware' || (h.method == req.method && paths.match(h.path, req.path));
  });
  async.eachSeries(matchingHandlers, function(handler, next) {
    res._callback = next;
    handler.handler(req, res);
  }, callback);
};

function checkConflictingRoutes(handlers, route) {
  var conflict = _.find(handlers, function(handler) {
    return handler.type == 'route' && handler.method == route.method &&
        (paths.match(handler.path, route.path) || paths.match(route.path, handler.path));
  });
  if (conflict) {
    throw new Error('Route conflict: ' + JSON.stringify(conflict) + ' and ' + JSON.stringify(route));
  }
}

module.exports = Lambda;
